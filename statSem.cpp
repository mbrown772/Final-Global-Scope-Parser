#include <iostream>
#include <sstream>

#include "statSem.h"



SemanticTable::SemanticTable()
{
  this->table.clear();
}

/*
 * Definition: Inserts a row into the semantic table
 * Passed:     Variable name and line number it was found on
 */
void SemanticTable::insert(const std::string VARNAME, const int LINE)
{
  Row newRow = { VARNAME, false, LINE };
  this->table.push_back(newRow);
}

/*
 * Definition: Checks if the table has a given VARNAME.Saves its location in the table to location
 * Passed:     The VARNAME we are looking for and a integer location to save its location in the table
 * Returns:    True if found otherwise false
 */
bool SemanticTable::contains(const std::string VARNAME, int& location)
{
  for(size_t i = 0; i < this->table.size(); i++)
  {
    if(this->table[i].varName == VARNAME)
    {
      location = i;
      return true;
    }
  }
  
  return false;
}



/*
 * Definition: This function builds the semantic table. It traverses in preorder.
 *             Throws a invalid_argument if the variable is declare more than once or if a variable is used without declaration.
 * Passed:     The root of the parse tree
 */
void SemanticTable::buildSemanticTable(const std::unique_ptr<Node>& NODE)
{
  if(NODE != nullptr)
  {
    if(NODE->label == "varlist") //All variable declarations are in varlist
    {
      int location = 0; //so we can print where it was first declared
      if(this->contains(NODE->tokens[0].instance, location))
      {
        std::stringstream error;
        error << "ERROR Line "<< NODE->tokens[0].line << ": " << NODE->tokens[0].instance << " redeclared!";
        error << "\nERROR Line " << this->table[location].line << ": " << NODE->tokens[0].instance << " previously declared here!";
        throw std::invalid_argument(error.str());
      }
      
      this->insert(NODE->tokens[0].instance, NODE->tokens[0].line);
    }
    else //Every other node than varlist
    {
      if(!NODE->tokens.empty())
      {
        if(NODE->tokens[0].tokenId == "ID_tk") //ID is being used make sure it is in the table
        {
          int location = 0;
          if(this->contains(NODE->tokens[0].instance, location))
          {
            table[location].used = true;
          }
          else
          {
            std::stringstream error;
            error << "ERROR Line " << NODE->tokens[0].line << ": " << NODE->tokens[0].instance << " undefined!";
            throw std::invalid_argument(error.str());
          }
        }
      }
    }
    
    buildSemanticTable(NODE->child1);
    buildSemanticTable(NODE->child2);
    buildSemanticTable(NODE->child3);
    buildSemanticTable(NODE->child4);
  }
}

//Definition: Prints warning if a variable has not been used by the program
void SemanticTable::printWarnings()
{
  for(size_t i = 0; i < this->table.size(); i++)
  {
    if(!table[i].used)
    {
      std::cout << "WARNING Line " << table[i].line << ": " << table[i].varName << " assigned but never used!" << std::endl;
    
    }
  }
}


void SemanticTable::tableOut(std::ofstream& fileOut)
{
  for(size_t i = 0; i < this->table.size(); i++)
    fileOut << table[i].varName << " 0" << std::endl;
}


/*
 * Definition: This function checks the static semantics of the given parse tree and generates a table of variables in the program.
 *             Scope is global. Redecleration of variables or using without being initialized is an error/
 *             The fucntion then prints warnings for variables declared but not used.
 * Passed:     The root of the parse tree generated by the parser for the language.            
 * Returns:    A pointer to the generated semantic table.
 */
std::unique_ptr<SemanticTable> buildTable(const std::unique_ptr<Node>& ROOT)
{
  
  std::unique_ptr<SemanticTable> table(new SemanticTable());
  try
  {
    table->buildSemanticTable(ROOT); //Build sematic table (statsem.h)
    table->printWarnings();
  } 
  catch(const std::invalid_argument &e) //Error in static semantics
  {
    std::cout << e.what() << std::endl;
    table = nullptr; //We errored 
  }
  
  return table;
}
